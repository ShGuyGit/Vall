#update range of pcs for zero-days
#computers = "OU=Computers,OU=Company,DC=Poobah,DC=com"
$computers = @("computer1", "computer2", "computer3")
foreach ($computer in $computers) {
    $session = New-PSSession -ComputerName $computer
    Invoke-Command -Session $session -ScriptBlock {
        & 'C:\Program Files\Common Files\Microsoft Shared\ClickToRun\OfficeC2RClient.exe' /update user
    }
    Remove-PSSession -Session $session
}

#last replication status
echo '-----------'
echo 'Checking last replication status between XXXX and XXXX sites...'
echo "-----------"
Get-ADReplicationLink -SiteName xxxxx | ? { $_.sourceserver -eq 'XXXX' } | select sourceserver,destinationserver,LastSuccessfulsync,lastsyncmessage
Get-ADReplicationLink -SiteName xxxx | ? { $_.sourceserver -eq 'XXXX' } | select sourceserver,destinationserver,LastSuccessfulsync,lastsyncmessage


#find all existing DHCP scopes
Get-DhcpServerv4Scope

# Create an IPv4 DHCP Server Scope
 $HashArgs = @{
     'Name' = 'Head Office Wireless Scope';  # This sets the name of the wireless scope
     'Description' = 'Wireless Clients';     # This is the human-readable description of the scope
     'StartRange' = '10.1.0.100';            # Specifies the starting IP address in the scope
     'EndRange' = '10.1.0.200';              # Specifies the end IP address in the scope
     'SubnetMask' = '255.255.255.0';         # Specifies the subnet mask of the scope
     'State' = 'Active';                     # Activates the scope
     'LeaseDuration' = '1.00:00:00';         # Specifies the length of the lease duration
 }
 #Add-DhcpServerv4Scope @HashArgs

#auditing
#Present application, security, and system logs in an array.
 $arrLogs = @(
     "Application"
     "Security"
     "System"
 )
 #Use the ForEach-Object cmdlet to target each respective log with the Get-ItemProperty cmdlet.
 $arrLogs | ForEach-Object {
     #Use Get-ItemProperty cmdlet to list the configured file path for the application, security, and system log.
     Get-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\$_ -Name File | Select-Object PSChildName,File
 }

#Obtain the system's audit policy configuration.
auditpol /get /category:*

#Set Logon Events to capture Success/Failure activity.
auditpol /set /subcategory:"Logon" /success:enable /failure:enable

#35 failed logon attempts which will be recorded in your systemâ€™s security log to mimic brute force activity.
Define 5 usernames to record as logon failures.
 $arrUsers = @(
     "Jacob"
     "Jill"
     "Shannon"
     "Mr Scary"
     "User5"
 )
 #Loop through usernames using ForEach-Object to generate a logon failure for each one.
 $arrUsers | ForEach-Object {
     $securePassword = ConvertTo-SecureString "AtA810GRu13Z%%" -AsPlainText -Force 
     $storedCredential = New-Object System.Management.Automation.PSCredential($_, $securePassword)
     Start-Process -FilePath PowerShell -Credential $storedCredential
 }
 #Generate 30 logon failures for user User5.
 $i = 0
 Do {
     $securePassword = ConvertTo-SecureString "9723HRTy234X%" -AsPlainText -Force 
     $storedCredential = New-Object System.Management.Automation.PSCredential("AtaBlogUser", $securePassword)
     Start-Process -FilePath PowerShell -Credential $storedCredential
     $i++
 } Until ($i -eq 30)

#Filter the security log for the first 10 instances of Event ID 4625
Get-WinEvent -FilterHashtable @{LogName='Security';ID=4625} -MaxEvents 10
#(Get-WinEvent -ListProvider 'Microsoft-Windows-Security-Auditing').Events
#(Get-WinEvent -ListProvider 'Microsoft-Windows-Security-Auditing').Events | Where-Object -Property ID -eq 4625
#Obtain event XML template for event properties of Event ID 4625.
 #((Get-WinEvent -ListProvider 'Microsoft-Windows-Security-Auditing').Events | Where-Object -Property ID -eq 4625).Template

#Get-WinEvent -FilterHashtable @{LogName='Security';ID=4625} -MaxEvents 1
#Get-WinEvent -FilterHashtable @{LogName='Security';ID=4625} -MaxEvents 1 | Select-Object -Property *
#Output event properties array for the first instance of Event ID 4625
 $eventProperties = (Get-WinEvent -FilterHashtable @{LogName='Security';ID=4625} -MaxEvents 1).properties
 $eventProperties

$eventProperties[5].value
$events = Get-WinEvent -FilterHashTable @{LogName="Security";ID=4625;StartTime=((Get-Date).AddDays(-1));EndTime=(Get-Date)}
#Extract TargetUserName, LogonType, WorkstationName, and IpAddress event properties from all instances of Event ID 4625 in the last 24 hours.
 $events | ForEach-Object {
     ## Reference the properties object property
     ## Only return the value of indexes 5,10,13 and 19 from the properties array
     ## Concatenate all values together by joining them with a comma
     $_.properties[5,10,13,19].value -join ", "
 }

$logonTypes = @{
     [uint32]2 = "Interactive"
     [uint32]3 = "Network"
     [uint32]4 = "Batch"
     [uint32]5 = "Service"
     [uint32]7 = "Unlock"
     [uint32]8 = "NetworkCleartext"
     [uint32]9 = "NewCredentials"
     [uint32]10 = "RemoteInteractive"
     [uint32]11 = "CachedInteractive"
 }

#Use Get-WinEvent to access the properties of each logged instance of Event ID 4625
$events = Get-WinEvent -FilterHashTable @{LogName="Security";ID=4625;StartTime=((Get-Date).AddDays(-1).Date);EndTime=(Get-Date)}
## Create the numerical value to string "map"
$logonTypes = @{
    [uint32]2 = "Interactive"
    [uint32]3 = "Network"
    [uint32]4 = "Batch"
    [uint32]5 = "Service"
    [uint32]7 = "Unlock"
    [uint32]8 = "NetworkCleartext"
    [uint32]9 = "NewCredentials"
    [uint32]10 = "RemoteInteractive"
    [uint32]11 = "CachedInteractive"
}
## Begin processing each object in the $events array
$events | ForEach-Object {
    ## Look up the numerical value in the hashtable
    $logonType = $logonTypes[$_.properties[10].value] 
    #Create custom PowerShell object to output relevant event properties 
    [PSCustomObject]@{     
        TimeCreated = $_.TimeCreated     
        TargetUserName = $_.properties[5].value     
        LogonType = $logonType     
        WorkstationName = $_.properties[13].value     
        IpAddress = $_.properties[19].value 
    }
} | Format-Table -Wrap

#Use Get-WinEvent to access the properties of each logged instance of Event ID 4625
$events = Get-WinEvent -FilterHashTable @{LogName="Security";ID=4625;StartTime=((Get-Date).AddDays(-1).Date);EndTime=(Get-Date)}
## Create the numerical value to string "map"
$logonTypes = @{
    [uint32]2 = "Interactive"
    [uint32]3 = "Network"
    [uint32]4 = "Batch"
    [uint32]5 = "Service"
    [uint32]7 = "Unlock"
    [uint32]8 = "NetworkCleartext"
    [uint32]9 = "NewCredentials"
    [uint32]10 = "RemoteInteractive"
    [uint32]11 = "CachedInteractive"
}
## Begin processing each object in the $events array
$events | ForEach-Object {
    ## Look up the numerical value in the hashtable
    $logonType = $logonTypes[$_.properties[10].value] 
    #Create custom PowerShell object to output relevant event properties 
    [PSCustomObject]@{     
        TimeCreated = $_.TimeCreated     
        TargetUserName = $_.properties[5].value     
        LogonType = $logonType     
        WorkstationName = $_.properties[13].value     
        IpAddress = $_.properties[19].value 
    }
} | Group-Object -Property TargetUserName | Sort-Object -Property Count -Descending

#$services | Group-Object -Property Status | Where {$_.Name -eq 'Stopped'} | Select -ExpandProperty Group


#research

$Titles = "Title - User1","Title - Admin1","Title - Admin2"

foreach($Title in $Titles){
    Get-ADuser -filter {title -eq $Title} | %{Add-ADGroupMember "SDK test print color" $_.SamAccountName} 
}


$folders = @('C:\Crash','C:\Program Files\Common Files','C:\Users\fxavi')
$folders | ForEach-Object (Add-Content -Path "$_\SampleFile343.txt" -Value "This is the stuff of contents of the file")

#1

# Create an array of folders
$folders = @('C:\Crash','C:\Program Files\Common Files','C:\Users\fxavi')

# Perform iteration to create the same file in each folder
foreach ($i in $folders) {Add-Content -Path "$i\SampleFilew.txt" -Value "This is thwe content of the file"}

#2
$folders = @('C:\Folder','C:\Program Files\Folder2','C:\Folder3')
$folders.ForEach({Add-Content -Path "$_\SampleFile.txt" -Value "This is the content of the file"})

#3
$servers = Get-Content .\servers.txt

foreach ($server in $servers) {
	try {
		$null = Test-Connection -ComputerName $server -Count 1 -ErrorAction STOP
		Write-Output "$server - OK"
	}
	catch {
		Write-Output "$server - $($_.Exception.Message)"
	}
}

#4
# Define the TOP-level folder
$TOP_FOLDER = "C:\ARCHIVE_VOLUMES"

# Get all sub folders recursively
$Child_Folders = Get-ChildItem -Path $TOP_FOLDER -Recurse | Where-Object { $_.PSIsContainer -eq $true }

# Create a text file in each sub-folder and add the current date/time as value.
foreach ($foldername in $Child_Folders.FullName) {
   (get-date -Format G) | Out-File -FilePath "$($foldername)\BackupState.txt" -Force
}

Get-ChildItem -Recurse -Path C:\ARCHIVE_VOLUMES -Include backupstate.txt | Select-Object Fullname,CreationTime,LastWriteTime,Length

#5
## Find all BackupState.txt files in C:\ARCHIVE_VOLUMES
$files = Get-ChildItem -Recurse -Path C:\ARCHIVE_VOLUMES -Include 'BackupState.txt' | Select-Object DirectoryName,FullName

## Read the contents of each file
foreach ($file in $files) {
    Write-Output ("$($file.DirectoryName) last backup time - " + (Get-Content $file.FullName))
}

#6
## Get a list of automatic services that are stopped.
$services = Get-Service | Where-Object {$.StartType -eq 'Automatic' -and $.Status -ne 'Running'}

## Pass each service object to the pipeline and process them with the Foreach-Object cmdlet
$services | ForEach-Object {
    try {
        Write-Host "Attempting to start '$($.DisplayName)'"
        Start-Service -Name $.Name -ErrorAction STOP
        Write-Host "SUCCESS: '$($.DisplayName)' has been started"
    } catch {
        Write-output "FAILED: $($.exception.message)"
    }
}

#7
# Import list of Firstname and Lastname from CSV file
$newUsers = Import-Csv -Path .\Employees.csv

Add-Type -AssemblyName System.Web

# Process the list
$newUsers.foreach(
    {
        # Generate a random password
        $password = [System.Web.Security.Membership]::GeneratePassword((Get-Random -Minimum 20 -Maximum 32), 3)
        $secPw = ConvertTo-SecureString -String $password -AsPlainText -Force

        # Formulate a username
        $userName = '{0}{1}' -f $_.FirstName.Substring(0, 1), $_.LastName

        # Build new user attributes
        $NewUserParameters = @{
            GivenName       = $_.FirstName
            Surname         = $_.LastName
            Name            = $userName
            AccountPassword = $secPw
        }

        try {
            New-AdUser @NewUserParameters -ErrorAction Stop
            Write-Output "User '$($userName)' has been created."
        }
        catch {
            Write-Output $_.Exception.Message
        }
    }
)


#8
#Generate a list of student usernames
$OuDistinguishedName = "The long ugly distinguished name of the student OU goes here"
$listOfStudentUserNames = Get-ADUser -SearchBase $OuDistinguishedName -Filter * | 
                            Select -ExpandProperty SamAccountName

#go through and delete folders for each student name
foreach($userName in $listOfStudentUserNames){
    
    #only bother if the student has a profile on the machine
    if( Test-Path -Path "C:\Users\$userName" ){
        #User profile exists

        #Delete the contents of the folders
        Get-ChildItem -Path "C:\Users\$userName\Downloads" | Remove-Item -Recurse -Force
        Get-ChildItem -Path "C:\Users\$userName\Videos" | Remove-Item -Recurse -Force
        #etc, etc...
    }
    else{
        #User profile doesn't exist, skip to next username
        continue
    }    
}
